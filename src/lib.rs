//! This Crate is heavily inspired by Ruby's `attr_reader`, `attr_writer`, and `attr_accessor`
//! macros, these auto generate getters/setters so that you can waste less time writing the
//! same simple code and can focus more on the interesting parts of your project!
//!
//! This Library provides `3` macros
//!
//! `attr_reader` - Generates getters for the provided field names
//!
//! `attr_writer` - Generates setters for the provided field names
//!
//! `attr_accessor` - Generates getters and setters for the provided field names
//!
//! _Each Macro takes parameters that are the field names to generate getters/setters for_
//!
//! Ruby:
//! ```ruby
//! class Person
//!     attr_accessor :name, :age
//!
//!     def initialize name, age
//!         @name = name
//!         @age = age
//!     end
//!
//!     # Created by attr_accessor
//!     # def name
//!     #   @name
//!     # end
//!
//!     # Created by attr_accessor
//!     # def age
//!     #   @age
//!     # end
//!
//!     # Created by attr_accessor
//!     # def age= new_age
//!     #   @age = new_age
//!     # end
//!
//!     # Created by attr_accessor
//!     # def name= new_name
//!     #   @name = new_name
//!     # end
//! end
//! ```
//!
//! Rust Equivalent:
//! ```rust
//! #[attr_accessor(name, age)]
//! struct Person {
//!     name: String,
//!     age: u64,
//! }
//!
//! impl Person {
//!     pub fn new(name: String, age: u64) -> Self {
//!         Person {name, age}
//!     }
//!
//!     // Created by attr_accessor
//!     // pub fn get_name(&self) -> &String {
//!     //   &self.name
//!     // }
//!
//!     // Created by attr_accessor
//!     // pub fn get_age(&self) -> &u64 {
//!     //  &self.age
//!     // }
//!
//!     // Created by attr_accessor
//!     // pub fn set_name(&mut self, value: String) {
//!     //  self.name = value;
//!     // }
//!
//!     // Created by attr_accessor
//!     // pub fn set_age(&mut self, value: u64) {
//!     //  self.age = value;
//!     // }
//! }
//! ```
extern crate proc_macro;
extern crate proc_macro2;

use proc_macro::{TokenStream, TokenTree};
use proc_macro2::Span;
use quote::quote;
use std::collections::HashMap;
use syn::{parse_macro_input, Fields, ItemStruct, Type};

/// # Description
/// Validates attributes to create getters or setters for
/// Relates the identifiers provided as input with fields in the Struct
///
/// # Parameters
/// args - attrs to generate functions for
///
/// fields - actual fields in struct
///
/// # Panics
/// If there are duplicate attributes to create getters/setters for
///
/// If a specified attribute isn't a field in the struct
///
/// If an attribute isn't an Ident (It's a Group or Literal)
///
/// # Returns
/// HashMap<String, Type> where the String is the attribute specified and the Type is the type of
/// the corresponding struct field
fn relate_args_to_fields(args: TokenStream, fields: Fields) -> HashMap<String, Type> {
    let mut map: HashMap<String, Type> = HashMap::new();
    for arg in args {
        match arg {
            TokenTree::Punct(..) => continue,
            TokenTree::Ident(ident) => {
                let ident = ident.to_string();
                match fields
                    .iter()
                    .find(|v| return v.ident.clone().unwrap() == ident)
                {
                    Some(field) => {
                        if map.contains_key(&ident) {
                            panic!("Duplicate Attr name specified \'{}\'", ident);
                        }
                        map.insert(ident, field.ty.clone());
                    }
                    None => panic!("Unknown field \'{}\'", ident),
                }
            }
            TokenTree::Group(field) => panic!("Unexpected token \'{}\', expected Ident", field),
            TokenTree::Literal(field) => panic!("Unexpected token \'{}\', expected Ident", field),
        }
    }
    map
}

/// # Description
/// Generates Getters for the provided identifiers
///
/// # Parameters
/// args - identifiers to create getters for
///
/// input - the Struct to create the getters for
///
/// # Compile Errors
/// This expects to be above a `struct`
///
/// The identifiers passed have to be fields in the `struct`
///
/// Duplicate identifiers aren't permitted
///
/// # Example
/// ```rust
/// #[attr_reader(name, age)]
/// // Identifiers don't have to be comma separated #[attr_reader(name age)] is equivalent
/// struct Person {
///     name: String,
///     age: u64,
/// }
///
/// impl Person {
///     pub fn new(name: String, age: u64) -> Self {
///         Person {name, age}
///     }
///
///     // Generated by macro
///     //pub fn get_name(&self) -> &String {
///     //  &self.name
///     //}
///
///     // Generated by macro
///     //pub fn get_age(&self) -> &u64 {
///     //  &self.age
///     //}
/// }
/// ```
#[proc_macro_attribute]
pub fn attr_reader(args: TokenStream, input: TokenStream) -> TokenStream {
    let structure = parse_macro_input!(input as ItemStruct);
    let structure_name = structure.ident.clone();
    let getters = relate_args_to_fields(args, structure.fields.clone());
    let mut getter_fns: Vec<proc_macro2::TokenStream> = Vec::new();
    for (key, value) in getters.iter() {
        getter_fns.push(create_getter(key, value));
    }
    (quote! {
        #structure
        impl #structure_name {
            #(#getter_fns)*
        }
    })
    .into()
}

/// # Description
/// Generates Setters for the provided identifiers
///
/// # Parameters
/// args - identifiers to create setters for
///
/// input - the Struct to create the setters for
///
/// # Compile Errors
/// This expects to be above a `struct`
///
/// The identifiers passed have to be fields in the `struct`
///
/// Duplicate identifiers aren't permitted
///
/// # Example
/// ```rust
/// #[attr_writer(name, age)]
/// // Identifiers don't have to be comma separated #[attr_writer(name age)] is equivalent
/// struct Person {
///     name: String,
///     age: u64,
/// }
///
/// impl Person {
///     pub fn new(name: String, age: u64) -> Self {
///         Person {name, age}
///     }
///
///     // Generated by macro
///     //pub fn set_name(&mut self, value: String) {
///     //  self.name = value;
///     //}
///
///     // Generated by macro
///     //pub fn set_age(&mut self, value: u64) {
///     //  self.age = value;
///     //}
/// }
/// ```
#[proc_macro_attribute]
pub fn attr_writer(args: TokenStream, input: TokenStream) -> TokenStream {
    let structure = parse_macro_input!(input as ItemStruct);
    let structure_name = structure.ident.clone();
    let setters = relate_args_to_fields(args, structure.fields.clone());
    let mut setter_fns: Vec<proc_macro2::TokenStream> = Vec::new();
    for (key, value) in setters.iter() {
        setter_fns.push(create_setter(key, value));
    }
    (quote! {
        #structure
        impl #structure_name {
            #(#setter_fns)*
        }
    })
    .into()
}

/// # Description
/// Generates Getters/Setters for the provided identifiers
///
/// # Parameters
/// args - identifiers to create getters/setters for
///
/// input - the Struct to create the getters/setters for
///
/// # Compile Errors
/// This expects to be above a `struct`
///
/// The identifiers passed have to be fields in the `struct`
///
/// Duplicate identifiers aren't permitted
///
/// # Example
/// ```rust
/// #[attr_accessor(name, age)]
/// // Identifiers don't have to be comma separated #[attr_accessor(name age)] is equivalent
/// struct Person {
///     name: String,
///     age: u64,
/// }
///
/// impl Person {
///     pub fn new(name: String, age: u64) -> Self {
///         Person {name, age}
///     }
///
///     // Generated by macro
///     //pub fn set_name(&mut self, value: String) {
///     //  self.name = value;
///     //}
///
///     // Generated by macro
///     //pub fn set_age(&mut self, value: u64) {
///     //  self.age = value;
///     //}
///
///     // Generated by macro
///     //pub fn get_name(&self) -> &String {
///     //  &self.name
///     //}
///
///     // Generated by macro
///     //pub fn get_age(&self) -> &u64 {
///     //  &self.age
///     //}
/// }
/// ```
#[proc_macro_attribute]
pub fn attr_accessor(args: TokenStream, input: TokenStream) -> TokenStream {
    let structure = parse_macro_input!(input as ItemStruct);
    let structure_name = structure.ident.clone();
    let field_map = relate_args_to_fields(args, structure.fields.clone());
    let mut fns: Vec<proc_macro2::TokenStream> = Vec::new();
    for (key, value) in field_map.iter() {
        fns.push(create_setter(key, value));
        fns.push(create_getter(key, value));
    }
    (quote! {
        #structure
        impl #structure_name {
            #(#fns)*
        }
    })
    .into()
}

/// # Description
/// Generate a Getter Function
///
/// # Parameters
/// attribute - name of attribute name that corresponds to a `struct` field name
///
/// attr_type - Type of the attribute
///
/// # Returns
/// A TokenStream that corresponds to the implemented getter function
///
/// # Example Output
/// ```rust
/// pub fn get_#name(&mut self) -> &#type {
///     &self.#name
/// }
/// ```
fn create_getter(attribute: &str, attr_type: &Type) -> proc_macro2::TokenStream {
    let fn_def = syn::Ident::new(&format!("get_{}", attribute), Span::call_site());
    let value = syn::Ident::new(&format!("{}", attribute), Span::call_site());
    (quote! {
        pub fn #fn_def(&self) -> &#attr_type {
            &self.#value
        }
    })
    .into()
}

/// # Description
/// Generate a Setter Function
///
/// # Parameters
/// attribute - name of attribute name that corresponds to a `struct` field name
///
/// attr_type - Type of the attribute
///
/// # Returns
/// A TokenStream that corresponds to the implemented setter function
///
/// # Example Output
/// ```rust
/// pub fn set_#name(&mut self, value: #type) {
///     self.#name = value;
/// }
/// ```
fn create_setter(attribute: &str, attr_type: &Type) -> proc_macro2::TokenStream {
    let fn_def = syn::Ident::new(&format!("set_{}", attribute), Span::call_site());
    let value = syn::Ident::new(&format!("{}", attribute), Span::call_site());
    (quote! {
        pub fn #fn_def(&mut self, value: #attr_type) {
            self.#value = value;
        }
    })
    .into()
}
